package com.example.demo.controllers;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.Calendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

import jakarta.validation.Valid;
import model.Club;
import model.Player;
import model.Transfer;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import com.example.demo.DTO.TransferDTO;
import com.example.demo.service.TransferService;
import com.example.demo.service.PlayerService; // pretpostavka: postoji
import com.example.demo.service.ClubService;   // pretpostavka: postoji

@RestController
@RequestMapping("/transfers")
@CrossOrigin(origins = "http://localhost:4200", allowCredentials = "true")
public class TransferController {

    @Autowired private TransferService transferService;
    @Autowired private PlayerService playerService; // ako se drugačije zove, prilagodi
    @Autowired private ClubService clubService;     // ako se drugačije zove, prilagodi

    // GET /transfers
    // GET /transfers?playerName=...&clubId=...&season=24/25
    @GetMapping
    public List<TransferDTO> list(
            @RequestParam(required = false) String playerName,
            @RequestParam(required = false) Long clubId,
            @RequestParam(required = false) String season
    ) {
        if ((playerName != null && !playerName.isBlank()) || clubId != null || (season != null && !season.isBlank())) {
            return transferService.searchTransfers(
                    (playerName != null && !playerName.isBlank()) ? playerName.trim() : null,
                    clubId,
                    (season != null && !season.isBlank()) ? season.trim() : null
            ).stream().map(this::toDto).collect(Collectors.toList());
        }
        return transferService.getAll().stream().map(this::toDto).collect(Collectors.toList());
    }

    // GET /transfers/{id}
    @GetMapping("/{id}")
    public ResponseEntity<TransferDTO> one(@PathVariable Long id) {
        Transfer t = transferService.getById(id);
        return (t == null) ? ResponseEntity.notFound().build() : ResponseEntity.ok(toDto(t));
    }

    // POST /transfers
    @PostMapping
    public ResponseEntity<?> create(@Valid @RequestBody TransferDTO dto) {

        // 1) Provera — ne dozvoljavamo današnji dan
        if (dto.getTransferDate() != null) {
            LocalDate today = LocalDate.now();
            LocalDate transferDay = dto.getTransferDate()
                    .toInstant()
                    .atZone(ZoneId.systemDefault())
                    .toLocalDate();

            if (transferDay.isEqual(today)) {
                Map<String, String> err = new HashMap<>();
                err.put("error", "Transfer se ne može uneti za današnji dan.");
                return ResponseEntity.badRequest().body(err);
            }
        }

        // 2) Standardno mapiranje DTO -> entitet i čuvanje
        Transfer entity = fromDto(dto, null);
        Transfer saved = transferService.save(entity);

        // Napomena:
        // - Ako je datum u prošlosti, transfer se samo beleži (tvoj service/scheduler
        //   treba da bude podešen da NE menja klub igraču retroaktivno).
        // - Ako je u budućnosti, scheduler (processTransfers) će promeniti klub
        //   kada dođe taj dan.
        return ResponseEntity.ok(toDto(saved));
    }

    // PUT /transfers/{id}
    @PutMapping("/{id}")
    public ResponseEntity<TransferDTO> update(@PathVariable Long id, @Valid @RequestBody TransferDTO dto) {
        Transfer existing = transferService.getById(id);
        if (existing == null) return ResponseEntity.notFound().build();

        Transfer merged = fromDto(dto, existing); // dopuni postojeći
        Transfer saved = transferService.save(merged);
        return ResponseEntity.ok(toDto(saved));
    }

    // DELETE /transfers/{id}
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        Transfer t = transferService.getById(id);
        if (t == null) return ResponseEntity.notFound().build();
        transferService.delete(id);
        return ResponseEntity.noContent().build();
    }

    // (opciono) DELETE /transfers/by-player-and-date?playerName=...&date=yyyy-MM-dd
    @DeleteMapping("/by-player-and-date")
    public ResponseEntity<Void> deleteByPlayerAndDate(@RequestParam String playerName,
                                                      @RequestParam String date) {
        try {
            java.util.Date d = new SimpleDateFormat("yyyy-MM-dd").parse(date);
            boolean ok = transferService.deleteByPlayerNameAndDate(playerName, d);
            return ok ? ResponseEntity.noContent().build() : ResponseEntity.notFound().build();
        } catch (ParseException e) {
            return ResponseEntity.badRequest().build();
        }
    }

    // ----------------- helper mapiranja -----------------

    private TransferDTO toDto(Transfer t) {
        TransferDTO dto = new TransferDTO();
        dto.setPlayerName(t.getPlayer() != null ? t.getPlayer().getName() : null);
        dto.setFromClubName(t.getFromClub() != null ? t.getFromClub().getName() : null);
        dto.setToClubName(t.getToClub() != null ? t.getToClub().getName() : null);
        dto.setTransferDate(t.getTransferDate());
        dto.setTransferFee(t.getTransferFee());
        dto.setSeason(computeSeasonFromDate(t.getTransferDate()));
        return dto;
    }

    /**
     * Mapira DTO -> entitet. Ako je target null, pravi novi Transfer,
     * inače apdejtuje postojeći.
     */
    private Transfer fromDto(TransferDTO dto, Transfer target) {
        Transfer t = (target != null) ? target : new Transfer();

        // playerName -> Player
        if (dto.getPlayerName() != null && !dto.getPlayerName().isBlank()) {
            Player p = playerService.findByName(dto.getPlayerName()); // prilagodi ako se metoda drugačije zove
            if (p != null) t.setPlayer(p);
        }

        // fromClubName -> Club
        if (dto.getFromClubName() != null && !dto.getFromClubName().isBlank()) {
            Optional<Club> from = clubService.findByName(dto.getFromClubName()); // ako vraća Club umesto Optional, prilagodi
            from.ifPresent(t::setFromClub);
        }

        // toClubName -> Club
        if (dto.getToClubName() != null && !dto.getToClubName().isBlank()) {
            Optional<Club> to = clubService.findByName(dto.getToClubName());
            to.ifPresent(t::setToClub);
        }

        if (dto.getTransferDate() != null) t.setTransferDate(dto.getTransferDate());
        if (dto.getTransferFee() != null) t.setTransferFee(dto.getTransferFee());

        // Napomena: 'season' se ne čuva u entitetu; derivira se iz datuma
        return t;
    }

    /**
     * Deriviše string sezone "YY/YY" na osnovu datuma transfera:
     * - Ako je mesec >= avgust (8), sezona je Y/ Y+1
     * - Ako je mesec <= maj (5), sezona je (Y-1) / Y
     */
    private String computeSeasonFromDate(java.util.Date date) {
        if (date == null) return null;
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH) + 1; // 1..12

        int startYear, endYear;
        if (month >= 8) { // avgust - decembar
            startYear = year % 100;
            endYear = (year + 1) % 100;
        } else if (month <= 5) { // januar - maj
            startYear = (year - 1) % 100;
            endYear = year % 100;
        } else {
            // jun/jul: formalno između sezona — približno ćemo računati kao prethodna sezona
            startYear = (year - 1) % 100;
            endYear = year % 100;
        }
        return String.format("%02d/%02d", startYear, endYear);
        }
}
